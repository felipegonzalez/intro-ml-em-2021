# Métodos lineales: regresión lineal


```{r, include = FALSE}
library(tidyverse)
theme_set(theme_minimal(base_size = 13))
cbb_palette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
scale_colour_discrete <- function(...) {
  scale_colour_manual(..., values = cbb_palette)
}
```

¿Cuál es la manera de superar la maldición de la dimensionalidad que mostramos
en la sección anterior? ¿Por qué
es posible resolver problemas en dimensión alta (imágenes, texto, múltiples características
sociodemográficas, etc)? La principal razón

- Muchos datos tienen estructuras o regularidades fuertes, lo que localiza su posición en
el espacio de dimensión alta (por ejemplo imágenes).
- Métodos más estructurados que incorporan esas regularidades pueden explotar
información que no necesariamente está "cerca" de donde queremos hacer predicciones.

El primer ejemplo de métodos estructurados es la regresión lineal. Si la respuesta
que nos interesa modelar tiene una relación aproximadamente lineal con las entradas,
entonces requerimos relativamente muy pocos datos para construir predicciones
buenas (en el caso extremo, piensa que solo necesitas dos datos para construir una recta:
si el problema es de ruido bajo y la relación es lineal, las predicciones de este modelo
serán muy buenas).

En **regresión lineal**, buscamos funciones de predicción de la forma:

$$f(x) = a_0 + a_1 x_1 + a_2 x_2 + \cdots + a_p x_p$$
donde $x_1,\ldots, x_p$ son las entradas. Es quizá la manera más simple
de combinar información de estas entradas: la predicción es una suma ponderada
de las entradas.

Nótese que antes de hacer predicciones, es necesario entrenar este modelo, 
que en este caso significa calcular los pesos $a_i$ apropiados. Una manera simple
es encontrar las $a_i$ que minimizan algún error *sobre la muestra de entrenamiento*.
Por ejemplo, si usamos el error cuadrático, y nuestro conjunto de entrenamiento
es $(x^{(1)}, y^{(1)}), (x^{(2)}, y^{(2)}), \ldots, (x^{(N)}, y^{(N)})$, podemos
intentar resolver

$$\min_{a_0, a_1, \ldots, a_p}\sum_{i=1}^N (y^{(i)} - f(x^{(i)}))^2$$

que también se puede escribir como

$$\min_{a_0, a_1, \ldots, a_p}\sum_{i=1}^N (y^{(i)} - a_0 - a_1 x^{(i)}_1 - \cdots   -a_p x^{(i)}_p)^2.$$
Este se llama un problema de *mínimos cuadrados*, y es posible resolverlo analíticamente
(derivando e igualando a cero), o con algún método numérico.

```{block2, type="resumen"}
- Nótese que el problema de arriba no intenta "minimizar el error de predicción". Simplemente
intenta ajustar los valores de $f(x)$ a las $y$ sobre la mustra de entrenamiento. 
- En realidad queremos minimizar el error de predicción, pero este está en términos
de la muestra de prueba, que no podemos usarla para entrenar el modelo lineal.
- En consecuencia, este problema de minimización generalmente no
es que queremos resolver, y muchas veces lo modificamos para
obtener mejor desempeño predictivo: esto lo veremos más adelante.
```


## Ejemplo: explotando estructura

Este segundo ejemplo también es de [@ESL]. Supongamos que estamos otra vez en un problema de dimensión alta, y ahora intentamos algo similar con una función que es razonable aproximar
con una función lineal. Esta función *solo depende de la primera entrada, y las demás
componentes de $x$ son ruido en términos del problema de predicción:

```{r}
fun_cuad <- function(x)  0.5 * (1 + x[1])^2
```

Y queremos predecir para $x=(0,0,\ldots,0)$, cuyo valor exacto es

```{r}
fun_cuad(0)
```

Los datos se generan de la siguiente forma:

```{r}
simular_datos <- function(p = 40){
    x_tbl <- map(1:1000,  ~ tibble(x = runif(p, -1, 1), nombre = paste0("x_", 1:p)))
    dat <- tibble(x_tbl = x_tbl) %>% 
      mutate(y = map_dbl(x_tbl, ~ fun_cuad(.x$x)))
    dat %>% unnest(cols = c(x_tbl)) %>% 
      pivot_wider(names_from = nombre, values_from = x)
}
```

Por ejemplo, para dimensión $p=1$ (nótese que una aproximación
lineal no es tan mala):

```{r, fig.width= 4, fig.height = 3}
ejemplo <- simular_datos(p = 1) 
ggplot(ejemplo, aes(x = x_1, y = y)) + geom_point() +
    geom_smooth(method = "lm")
```


Ahora simulamos el proceso en dimensión $p=40$: simulamos las entradas, y aplicamos un vecino más cercano

```{r} 
library(tidymodels)

set.seed(831)
dat <- simular_datos(p = 40)
origen <- dat %>% select(-y) %>% slice(1) %>% 
  mutate(across(where(is.numeric), ~ 0))
modelo_vmc <- nearest_neighbor(n = 1) %>% 
  set_mode("regression") %>% set_engine("kknn")
ajuste_vmc <- modelo_vmc %>% fit(y ~ ., dat) 
predict(ajuste_vmc, origen)
```

Este no es un resultado muy bueno (muy lejos de 0.5). Sin embargo, regresión se
desempeña considerablemente mejor:

```{r}
modelo_lineal <- linear_reg() 
ajuste_lineal <- modelo_lineal %>% fit(y ~ ., dat) 
predict(ajuste_lineal, origen)
```

Donde podemos ver que típicamente la predicción de regresión
es mucho mejor que la de 1 vecino más cercano (prueba con otras semillas). 

## Ejemplo: precios de casas

Algunas veces, encontrar la estructura apropiada puede requerir más trabajo
que simplemente escoger una familia de modelos. En el ejemplo de precios
de casas, por ejemplo, podriamos usar:

```{r, message = FALSE}
source("R/casas_traducir_geo.R")
casas_split <- initial_split(casas, prop = 0.75)
casas_entrena <- training(casas_split)
receta_casas <- 
  recipe(precio_miles ~ area_hab_m2 + calidad_gral + 
           area_garage_m2 + area_sotano_m2 + 
           area_lote_m2 + año_construccion + 
           aire_acondicionado + condicion_venta, 
         data = casas_entrena) %>% 
  step_filter(condicion_venta == "Normal") %>% 
  step_select(-condicion_venta, skip = TRUE) %>% 
  step_cut(calidad_gral, breaks = c(3, 5, 7, 8)) %>% 
  step_normalize(starts_with("area")) %>% 
  #step_discretize(año_construccion, num_breaks = 4) %>% 
  step_dummy(calidad_gral, aire_acondicionado) %>% 
  step_interact(terms = ~ c(area_hab_m2, area_garage_m2, area_sotano_m2):starts_with("calidad_gral"))
```

```{r}
receta_casas_prep <- prep(receta_casas, verbose = TRUE)
datos_tbl <- juice(receta_casas_prep)
```

```{r}
datos_tbl %>%
  mutate(across(where(is.numeric), round, 2)) %>% 
  DT::datatable(options = list(scrollX = TRUE))
```


```{r}
flujo_casas <- workflow() %>% 
  add_recipe(receta_casas) %>% 
  add_model(linear_reg() %>% set_engine("lm"))
ajuste <- fit(flujo_casas, casas_entrena)
```

```{r}
ajuste %>% pull_workflow_fit() %>% broom::tidy() %>% 
  mutate(across(where(is.numeric), round, 2)) %>% 
  select(term, estimate) %>% 
  DT::datatable()
```

Nótese que:

- En esta tabla están los coeficientes $a_i$ en las covariables que creamos a partir 
de las variables de entrada.
- El modelo lineal *no* tiene que ser lineal *en las variables que recibimos originalmente
en la tabla de datos*.
- En este ejemplo, convertimos algunas variables a *dummy*, y multiplicamos algunas
variables de área por esas variables dummy.

```{r}
metricas <- metric_set(mape, mae, rmse)
casas_prueba <- testing(casas_split)
metricas(casas_prueba %>% bind_cols(predict(ajuste, casas_prueba)), 
     truth = precio_miles, estimate = .pred)
```

## Regresión lineal: controlando complejidad

Como vimos en el ejemplo anterior, en algunos casos podemos construir modelos
lineales de complejidad considerable (por ejemplo, transformando variables, incluyendo
interacciones). Es posible entonces que la variabilidad de las estimaciones sea 
grande, es decir, sobreajustar.

Veamos primero un ejemplo simulado

## Ejemplo: datos simulados y varianza

Considermeos un problema donde tenemos unas 100 entradas con 300 casos. Supondremos
que la función verdadera es 

$$f(x) = \sum_{j=1}^{100} a_j x_j$$

```{r}
set.seed(28015)
a_vec <- rnorm(100, 0, 0.1)
a <- tibble(term = paste0('V', 1:length(a_vec)), valor = a_vec)
head(a)
```

```{r}
sim_datos <- function(n, beta){
  p <- nrow(beta)
  mat_x <- matrix(rnorm(n * p, 0, 0.5), n, p) + rnorm(n, 0, 1) 
  colnames(mat_x) <- beta %>% pull(term)
  beta_vec <- beta %>% pull(valor)
  f_x <- mat_x %*% beta_vec 
  y <- as.numeric(f_x) + rnorm(n, 0, 1)
  datos <- as_tibble(mat_x) 
  datos %>% mutate(y = y)
}
set.seed(99121)
datos <- sim_datos(n = 4000, beta = a)
```

```{r}
library(tidymodels)
separacion <- initial_split(datos, 0.03)
dat_ent <- training(separacion)
modelo <-  linear_reg() %>% set_engine("lm")
receta <- recipe(y ~ ., dat_ent)
flujo <- workflow() %>% 
  add_model(modelo) %>% 
  add_recipe(receta)
mod_1  <- fit(flujo, dat_ent) %>% pull_workflow_fit()
```

```{r}
coefs_1 <- tidy(mod_1) %>% 
  left_join(a)
```

```{r}
ggplot(coefs_1 %>% filter(term != "(Intercept)"), 
       aes(x = valor, y = estimate)) +
  geom_point() +
  xlab('Coeficientes') + 
  ylab('Coeficientes estimados') +
  geom_abline() 
```

Y notamos que las estimaciones no son buenas. Podemos hacer otra simulación para confirmar que el problema es que las estimaciones son muy variables.

Con otra muestra de entrenamiento, vemos que las estimaciones tienen varianza alta.

```{r}
datos_ent_2 <- sim_datos(n = 120, beta = a)
mod_2 <- fit(flujo, datos_ent_2) %>% pull_workflow_fit()
coefs_2 <- tidy(mod_2)
qplot(coefs_1$estimate, coefs_2$estimate) + xlab('Coeficientes mod 1') + 
  ylab('Coeficientes mod 2') +
  geom_abline(intercept=0, slope =1)
```

En la práctica, nosotros tenemos una sola muestra de entrenamiento. Así que, con una muestra de tamaño  
$n=200$
  como en este ejemplo, obtendremos típicamente resultados no muy buenos. Estos coeficientes ruidosos afectan nuestras predicciones de manera negativa.
  
```{r}
library(patchwork)
dat_pr <- testing(separacion)
p_entrena <- predict(mod_1, dat_ent) %>% 
  bind_cols(dat_ent %>% select(y))
p_prueba <- predict(mod_1, dat_pr) %>% 
  bind_cols(dat_pr %>% select(y))
g_1 <- ggplot(p_entrena, aes(x = .pred, y = y)) + 
  geom_point() + 
  xlab("Predicción") + ylab("y")
g_2 <- ggplot(p_prueba, aes(x = .pred, y = y)) + 
  geom_point() + 
  xlab("Predicción") + ylab("y")
g_1 + g_2
```

## Ejemplo: controlando la varianza

Como el problema es la variabilidad de los coeficientes (no hay sesgo pues conocemos el modelo verdadero), podemos atacar este problema poniendo restricciones a los coeficientes, de manera que caigan en rangos más aceptables. Una manera de hacer esto es sustituir el problema de minimización de regresión, que es minimizar:


$$\min_a D(a)$$

con un problema penalizado

$$\min_a D(a) + \lambda \sum_{j=1}^p a_j^2$$
Si escogemos un valor relativamente grande de  $\lambda$, entonces 
terminaremos con una solución donde los coeficientes  
  no pueden alejarse mucho de 0, y esto previene parte del sobreajuste que observamos en nuestro primer ajuste. 
  Otra manera de decir esto es: intentamos minimizar cuadrados, pero no permitimos 
  que los coeficientes se alejen demasiado de cero.

También es posible poner restricciones sobre el tamaño de  $\sum_j a_j^2, lo cual es equivalente al problema de penalización.

En este caso obtenemos

```{r}
modelo_reg <-  linear_reg(mixture = 0, penalty = 0.1) %>% 
  set_engine("glmnet") 
flujo_reg <- workflow() %>% 
  add_model(modelo_reg) %>% 
  add_recipe(receta)
flujo_reg <- fit(flujo_reg, dat_ent)
mod_reg  <- flujo_reg %>% pull_workflow_fit()
```


```{r}
coefs_penalizado <- tidy(mod_reg) 
coefs_penalizado
```

```{r}
sum(coefs_penalizado$estimate^2)
```

```{r}
sum(coefs_1$estimate^2)
```


Los nuevos coeficientes estimados tienen menor variación:


```{r}
qplot(coefs_1$estimate, coefs_penalizado$estimate) + 
  xlab('Coeficientes') + 
  ylab('Coeficientes estimados') +
  geom_abline()
```

```{r}
p_prueba_2 <- predict(mod_reg, dat_pr) %>% 
  bind_cols(dat_pr %>% select(y))
g_3 <- ggplot(p_prueba_2, aes(x = .pred, y = y)) + 
  geom_point() + 
  xlab("Predicción") + ylab("y")
g_2 + g_3
```


```{r}
metricas <- metric_set(mae, rmse)
metricas(p_prueba, truth = y, estimate = .pred)
metricas(p_prueba_2, truth = y, estimate = .pred)
```

Y vemos que los errores de predicción se reducen en más de la mitad.

